<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Teleprompter</title>

  <!-- Manifest & SW -->
  <link rel="manifest" href="manifest.webmanifest">
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("sw.js");
    }
  </script>

  <style>
    
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    header {
      background: #111;
      display: flex;
      justify-content: space-around;
      padding: 0.5em;
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 10;
    }
    button {
      font-size: 1em;
      background: #222;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 0.5em;
      cursor: pointer;
    }
    #prompter {
      margin-top: 60px;
      flex: 1;
      font-size: 2em;
      line-height: 1.5;
      padding: 2em;
      overflow-y: auto;
      transition: transform 0.3s linear;
    }
    #editorModal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    #editorModal textarea {
      width: 90%;
      height: 70%;
      font-size: 1.2em;
      background: #222;
      color: #fff;
    }
    #editorModal button {
      margin-top: 1em;
    }
    .dark {
      background: #000;
      color: #fff;
    }
    .light {
      background: #fff;
      color: #000;
    }
  </style>
</head>
<body>
  <header>
    <button id="playBtn">‚ñ∂Ô∏è</button>
    <button id="fontMinus">A-</button>
    <button id="fontPlus">A+</button>
    <button id="speedMinus">-‚è©</button>
    <button id="speedPlus">+‚è©</button>
    <button id="mirrorBtn">ü™û</button>
    <button id="fullscreenBtn">‚õ∂</button>
    <button id="themeBtn">üåó</button>
    <button id="editBtn">üìù</button>
  </header>

  <div id="prompter" contenteditable="false">
    Welcome to your Teleprompter PWA.  
    Click üìù Edit text to paste your script.  
    Then hit ‚ñ∂Ô∏è to start scrolling.
  </div>

  <!-- Edit Modal -->
  <div id="editorModal">
    <div>
      <textarea id="editor"></textarea><br>
      <button id="saveTextBtn">Save</button>
      <button id="closeEditorBtn">Close</button>
    </div>
  </div>

  <script>
    const prompter = document.getElementById("prompter");
    const playBtn = document.getElementById("playBtn");
    const fontMinus = document.getElementById("fontMinus");
    const fontPlus = document.getElementById("fontPlus");
    const speedMinus = document.getElementById("speedMinus");
    const speedPlus = document.getElementById("speedPlus");
    const mirrorBtn = document.getElementById("mirrorBtn");
    const fullscreenBtn = document.getElementById("fullscreenBtn");
    const themeBtn = document.getElementById("themeBtn");
    const editBtn = document.getElementById("editBtn");

    const editorModal = document.getElementById("editorModal");
    const editor = document.getElementById("editor");
    const saveTextBtn = document.getElementById("saveTextBtn");
    const closeEditorBtn = document.getElementById("closeEditorBtn");

    let scrolling = false;
    let speed = 1; // pixels per frame
    let scrollInterval;
    let fontSize = 2; // em
    let mirrored = false;
    let darkMode = true;

    // Load saved state
    window.onload = () => {
      if(localStorage.getItem("prompterText")) {
        prompter.innerHTML = localStorage.getItem("prompterText");
      }
      if(localStorage.getItem("fontSize")) {
        fontSize = parseFloat(localStorage.getItem("fontSize"));
        prompter.style.fontSize = fontSize + "em";
      }
      if(localStorage.getItem("theme") === "light") {
        document.body.classList.remove("dark");
        document.body.classList.add("light");
        darkMode = false;
      }
    };

    playBtn.onclick = () => {
      if(!scrolling) {
        scrolling = true;
        playBtn.textContent = "‚è∏Ô∏è";
        scrollInterval = setInterval(() => {
          prompter.scrollTop += speed;
        }, 30);
      } else {
        scrolling = false;
        playBtn.textContent = "‚ñ∂Ô∏è";
        clearInterval(scrollInterval);
      }
    };

    fontMinus.onclick = () => {
      fontSize = Math.max(1, fontSize - 0.2);
      prompter.style.fontSize = fontSize + "em";
      localStorage.setItem("fontSize", fontSize);
    };
    fontPlus.onclick = () => {
      fontSize += 0.2;
      prompter.style.fontSize = fontSize + "em";
      localStorage.setItem("fontSize", fontSize);
    };

    speedMinus.onclick = () => speed = Math.max(0.5, speed - 0.5);
    speedPlus.onclick = () => speed += 0.5;

    mirrorBtn.onclick = () => {
      mirrored = !mirrored;
      prompter.style.transform = mirrored ? "scaleX(-1)" : "none";
    };

    fullscreenBtn.onclick = () => {
      if(!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    };

    themeBtn.onclick = () => {
      darkMode = !darkMode;
      document.body.classList.toggle("light", !darkMode);
      document.body.classList.toggle("dark", darkMode);
      localStorage.setItem("theme", darkMode ? "dark" : "light");
    };

    editBtn.onclick = () => {
      editor.value = prompter.innerHTML.replace(/<br>/g, "\n");
      editorModal.style.display = "flex";
    };
    saveTextBtn.onclick = () => {
      prompter.innerHTML = editor.value.replace(/\n/g, "<br>");
      localStorage.setItem("prompterText", prompter.innerHTML);
      editorModal.style.display = "none";
    };
    closeEditorBtn.onclick = () => {
      editorModal.style.display = "none";
    };
  </script>
  <!-- ===== Camera Pack (front camera only) ===== -->
<style>
#camDock{position:fixed;right:12px;bottom:12px;z-index:9999;background:rgba(0,0,0,.65);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.15);border-radius:10px;padding:10px;display:flex;flex-direction:column;gap:8px}
#camDock button,#camDock select,#camDock a{font:14px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;border:1px solid rgba(255,255,255,.2);background:#1b1e27;color:#e9eef5;border-radius:8px;padding:6px 10px;cursor:pointer}
#camDock button:hover,#camDock a:hover{background:#232838}
#camDock .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
#camPreview{width:220px;max-width:40vw;border-radius:8px;background:#000;display:block}
#saveModal{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:10000}
#saveModal .card{background:#0e0f13;color:#e9eef5;border:1px solid rgba(255,255,255,.15);border-radius:12px;padding:14px;min-width:260px}
#saveModal .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
.hidden{display:none!important}
</style>

<div id="camDock">
<video id="camPreview" playsinline autoplay muted></video>
<div class="row">
<button id="camToggle">üé• Camera: Off</button>
<select id="resSel" title="Resolution">
<option value="720">720p</option>
<option value="1080" selected>1080p</option>
<option value="2160">2160p</option>
</select>
<button id="micMute" disabled>üîá Mute</button>
</div>
<div class="row">
<button id="recStart" disabled>‚è∫ Start</button>
<button id="recStop" class="hidden">‚èπ Stop</button>
<span id="recStat" style="color:#9aa4b2;font-size:12px">Ready</span>
</div>
</div>

<div id="saveModal">
<div class="card">
<div><b>Recording finished</b></div>
<div id="fileInfo" style="color:#9aa4b2;margin-top:6px;font-size:13px"></div>
<div class="actions">
<button id="deleteClip">Delete</button>
<a id="downloadClip" class="btn" download>Save</a>
</div>
</div>
</div>

<script>
(function(){
const $ = (id)=>document.getElementById(id);
const preview=$('camPreview'), camToggle=$('camToggle'), resSel=$('resSel'), micMute=$('micMute');
const recStart=$('recStart'), recStop=$('recStop'), recStat=$('recStat');
const saveModal=$('saveModal'), downloadClip=$('downloadClip'), deleteClip=$('deleteClip'), fileInfo=$('fileInfo');

let stream=null, mediaRecorder=null, chunks=[], isMuted=false, startedAt=0;

function wantedConstraints(){
const v=resSel.value;
const w=v==='2160'?3840:(v==='1080'?1920:1280);
const h=v==='2160'?2160:(v==='1080'?1080:720);
return { video:{ width:{ideal:w}, height:{ideal:h}, frameRate:{ideal:30}, facingMode:'user' }, audio:true }; // FRONT CAM ONLY
}

function stopStream(s){ if(!s) return; s.getTracks().forEach(t=>t.stop()); }
function humanSize(bytes){ const u=['B','KB','MB','GB']; let i=0,n=bytes; while(n>=1024&&i<u.length-1){ n/=1024; i++; } return n.toFixed(1)+' '+u[i]; }
function filename(){ const d=new Date(),p=n=>String(n).padStart(2,'0'); return `Teleprompter_${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}_${p(d.getHours())}-${p(d.getMinutes())}-${p(d.getSeconds())}.webm`; }

async function startCamera(){
try{
stream && stopStream(stream);
stream = await navigator.mediaDevices.getUserMedia(wantedConstraints());
preview.srcObject = stream;
camToggle.textContent = 'üé• Camera: On';
recStart.disabled=false; micMute.disabled=false;
recStat.textContent='Ready';
}catch(err){
alert('Camera/Microphone permission or device error.\n'+(err.message||err));
camToggle.textContent='üé• Camera: Off';
recStart.disabled=true; micMute.disabled=true;
}
}

camToggle.onclick=async ()=>{
if(stream){ stopStream(stream); stream=null; preview.srcObject=null; camToggle.textContent='üé• Camera: Off'; recStart.disabled=true; micMute.disabled=true; }
else { await startCamera(); }
};
resSel.onchange=async ()=>{ if(stream) await startCamera(); };
micMute.onclick=()=>{ if(!stream) return; isMuted=!isMuted; stream.getAudioTracks().forEach(t=>t.enabled=!isMuted); micMute.textContent=isMuted?'Unmute':'üîá Mute'; };

// Recording
recStart.onclick=async ()=>{
if(!stream) await startCamera();
try{
chunks=[];
const opts = MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus') ? {mimeType:'video/webm;codecs=vp9,opus'} :
MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus') ? {mimeType:'video/webm;codecs=vp8,opus'} : {};
mediaRecorder = new MediaRecorder(stream, opts);
mediaRecorder.ondataavailable = e => { if(e.data && e.data.size) chunks.push(e.data); };
mediaRecorder.onstop = onStop;
mediaRecorder.start(1000);
startedAt = Date.now();
recStart.classList.add('hidden'); recStop.classList.remove('hidden');
recStat.textContent='Recording‚Ä¶';
}catch(err){ alert('Recording not supported in this browser: '+(err.message||err)); }
};
recStop.onclick=()=>{
if(mediaRecorder && mediaRecorder.state!=='inactive') mediaRecorder.stop();
recStart.classList.remove('hidden'); recStop.classList.add('hidden');
};

function onStop(){
const blob = new Blob(chunks,{type:chunks[0]?.type||'video/webm'});
const url = URL.createObjectURL(blob);
const name = filename();
downloadClip.href = url; downloadClip.download = name;
const dur = ((Date.now()-startedAt)/1000).toFixed(1);
fileInfo.textContent = `File: ${name} ‚Ä¢ Duration: ${dur}s ‚Ä¢ Size: ${humanSize(blob.size)}`;
saveModal.style.display='flex';
recStat.textContent='Ready';
deleteClip.onclick=()=>{ saveModal.style.display='none'; URL.revokeObjectURL(url); };
downloadClip.onclick=()=>{ setTimeout(()=>URL.revokeObjectURL(url),5000); saveModal.style.display='none'; };
}
})();
</script>
<!-- ===== /Camera Pack ===== -->
</body>
</html>

